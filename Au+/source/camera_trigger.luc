/******************************************************************************
   This module generates two TTL signals intended at triggering a camera and 
   lasers. The fire trigger output can be used directly to trigger a camera,
   while the exposure trigger output can be processed by a laser_trigger module.
   
   It takes several parameters:
   * start: the output signals are only generated when start is HIGH, they are 
           0 otherwise.
   * pulse: pulse length of the fire trigger signal.
   * inter_frame: period between the end of exposure and the next fire pulse.
   * exposure: pulse length of the exposure trigger signal.
   * delay: delay of theexposure trigger signal with respect to the fire trigger.
      
   Outputs:
   * fire_trigger: camera fire signal.
   * exposure_trigger: camera exposure signal, intended to trigger laser_trigger
                     modules.
   
   Example: 
                                         inter frame
                                             <->
               <-pulse->
               ---------                        ---------      high    
              |         |                      |         |
   camera -----         ------------------------         ----- low
   
                 <---------exposure--------->
                  ---------------------------      ----------- high
                 |                           |    |        
   exposure ------                           ------            low
              <->delay
   
   Written by Joran Deschamps, EMBL (2021)
   https://mufpga.github.io/ 
   GPL-3.0 License  
*/
module camera_trigger (
    input clk,  // clock
    input rst,  // reset
    input start,
    input pulse[16], // pulse length of the camera trigger
    input inter_frame[16], // period of the camera trigger
    input exposure[16], // exposure of a camera frame (for the lasers)
    input delay[16], // delay for the laser exposure
    output fire_trigger,
    output exposure_trigger
  ) {

  // 16 bits -> maximum of 6.5s with NM_CYCLES = 10000, since clock cycle = 100MHz
  const NM_CYCLES = 10000; // convert to NM_CYCLES x 1e-8 = ~100 us
  const DELAY_CYCLES = 1000; // ~10 us
  var pulse_cycle;
  var period_cycle;
  var exposure_cycle;
  var delay_cycle;
  
  .clk(clk){ 
    .rst(rst) {
      // If x is the number of bits of pulse/delay/exposure/inter_frame
      // i.e. Nbits(trigger_length) = X
      // Then, we must have Nbits(counter) > log2((2^X-1)*NM_CYCLES+1)
      // For X=16 and NM_CYCLES = 10000, it yields Nbits(counter) > 29.3
      // For X=16 and DELAY_CYCLES = 1000, it yields Nbits(counter) > 25.9
      // since we add 3 16bits numbers in perdio_cycle, then we need
      // X=18 to cover the maximum value:
      // X=18 and NM_CYCLES = 10000 yields Nbits(counter) > 31.3
      dff counter[32]; // cycles counter
      dff delay_counter[26]; // delay counter
    }
  }
  
  always {
    pulse_cycle = pulse*NM_CYCLES;
    period_cycle = (delay+exposure+inter_frame)*NM_CYCLES;
    exposure_cycle = exposure*NM_CYCLES;
    delay_cycle = delay*DELAY_CYCLES;
    
    // increase counters until they max out
    if (!&counter.q){ 
      counter.d = counter.q + 1;
    }
    if (!&delay_counter.q){ 
      delay_counter.d = delay_counter.q + 1;
    }
    
    // reset counters every period
    if (counter.q >= period_cycle && start){
      counter.d = 0;
      delay_counter.d = 0;
    }
    
    // set output signals
    fire_trigger = counter.q < pulse_cycle;
    exposure_trigger = delay_counter.q > delay_cycle && counter.q < delay_cycle+exposure_cycle;    
  }
}
